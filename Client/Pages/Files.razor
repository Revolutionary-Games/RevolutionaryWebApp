@page "/files/{*FileBrowserPath}"
@inject HttpClient Http
@inject NavigationManager NavManager
@inject IJSRuntime JS
@inject ComponentUrlHelper URLHelper
@inject NotificationHandler NotificationHandler
@inject CurrentUserInfo CurrentUserInfo
@using RevolutionaryWebApp.Shared
@using RevolutionaryWebApp.Shared.Models
@using RevolutionaryWebApp.Shared.Notifications
@using RevolutionaryWebApp.Client.Services
@using System.Threading
@using System.Net
@using System.Text.Json
@using DevCenterCommunication.Models
@using DevCenterCommunication.Models.Enums
@using SharedBase.Utilities
@using RevolutionaryWebApp.Client.Utilities
@using RevolutionaryWebApp.Shared.Forms
@using RevolutionaryWebApp.Shared.Models.Enums
@using RevolutionaryWebApp.Shared.Utilities
@implements RevolutionaryWebApp.Client.Services.INotificationHandler<FolderContentsUpdated>
@implements RevolutionaryWebApp.Client.Services.INotificationHandler<StorageItemUpdated>
@inherits BaseFileBrowser<DevCenterCommunication.Models.StorageItemInfo>
<h3>Files</h3>

<p>This is a service to store files needed for Thrive development, which aren't included in the code repository.</p>

<Breadcrumbs BasePath="@BasePath" CurrentPath="@FileBrowserPath" RootPathName="Files"/>

@if (!string.IsNullOrEmpty(Error))
{
    <div class="alert alert-danger" role="alert">
        @Error
    </div>

    @if (!CurrentUserInfo.LoggedIn)
    {
        <NavLink href="@NavManager.GetLinkToLogin()">Login Here</NavLink>
    }
}
else
{
    @if (shownFile != null)
    {
        <ItemSideBar Item="@shownFile" PreventClose="@ShouldShowUploaderOverlay"/>

        <DevCenterTitle>File @shownFile.Name</DevCenterTitle>
    }
    else
    {
        <DevCenterTitle>Files at "/@(FileBrowserPath ?? string.Empty)"</DevCenterTitle>
    }

    <div class="block-container" @ondragenter="HandleDragEnter" @ondragleave="HandleDragLeave">
        @if (ShouldShowUploaderOverlay)
        {
            <div @ref="dropArea" class="block-overlay"
                 @ondragenter="HandleDragEnter" @ondragleave="HandleDragLeave" @ondrop="OnDrop"
                 @ondragover="HandleDragOver"
                 @ondragover:preventDefault="@true"
                 @ondrop:preventDefault="@true">

                @if (!folderIsWritable)
                {
                    <div class="alert alert-danger drop-area" role="alert">
                        You don't have write access to this folder
                    </div>
                }

                @foreach (var error in uploadErrors)
                {
                    <p class="drop-area">Upload error: @error</p>
                }

                @if (uploadErrors.Count > 0)
                {
                    <Button class="mb-1" Enabled="@(!uploadInProgress)" ButtonStyle="secondary"
                            OnPressed="@ClearUploadErrors">
                        Clear Errors
                    </Button>
                }

                @if (!string.IsNullOrEmpty(uploadStatus))
                {
                    <p>@uploadStatus</p>
                }

                @if (uploadInProgress)
                {
                    @if (!string.IsNullOrEmpty(currentFileUploadMessage))
                    {
                        <div>@currentFileUploadMessage</div>
                    }

                    <div class="spinner-border text-primary mb-3 drop-area" role="status">
                        <span class="visually-hidden">Uploading...</span>
                    </div>
                }

                <p class="drop-area">Drop files here to upload.</p>

                <br class="mt-2 drop-area"/>

                <form>
                    <div class="row">
                        <label class="form-label drop-area pt-1 pe-1" for="filesToUploadSelection">
                            Or select files to upload:
                        </label>
                        <InputFile id="filesToUploadSelection"
                                   accept="*"
                                   OnChange="OnInputFilesChanged"
                                   @ondragenter="HandleDragEnter"
                                   @ondragleave="HandleDragLeave"
                                   multiple/>
                    </div>

                    <br class="drop-area"/>
                    <div class="row justify-content-center">
                        <Button class="my-1 me-1" Enabled="@(!uploadInProgress && filesToBeUploaded.Count > 0)"
                                OnPressed="@StartFileSelectorUploads" Spinner="@uploadInProgress">
                            Upload
                        </Button>
                        <Button class="my-1" Enabled="@(!uploadInProgress)" ButtonStyle="secondary"
                                OnPressed="@CloseUploaderFormIfCanBeClosed">
                            Cancel
                        </Button>
                    </div>
                </form>
            </div>
        }

        <PaginatedTable ShowPaginator="@(Data != null)" CurrentPage="@Data?.CurrentPage" PageCount="@Data?.PageCount"
                        OnPageChanged="async e => await ChangePage(e)"
                        OnSortChanged="async column => await ChangeSort(column)"
                        GetSortClass="@SortClass"
                        ShowContentSpinner="@VisibleFetchInProgress"
                        Columns="@columns"
                        ShowNoContent="@NoItemsFound"
                        UseNonFixedColumns="@true">
            @if (Data != null)
            {
                @foreach (var item in Data.Results)
                {
                    <tr @key="item.Id">
                        @if (item.Ftype == FileType.Folder)
                        {
                            <td>
                                <i class="fa-solid fa-folder"></i>
                                <span class="visually-hidden">Folder</span>
                            </td>
                        }
                        else
                        {
                            <td></td>
                        }

                        <th scope="row">
                            <NavLink href="@FolderLink(item.Name, shownFile != null)">@item.Name</NavLink>
                        </th>

                        @if (!item.Size.HasValue)
                        {
                            <td>?</td>
                        }
                        else if (item.Ftype == FileType.Folder)
                        {
                            <td>@("item".PrintCount(item.Size.Value))</td>
                        }
                        else
                        {
                            <td>@item.Size.Value.BytesToMiB()</td>
                        }

                        <td>@item.ReadAccess.ToUserReadableString()</td>
                    </tr>
                }
            }
        </PaginatedTable>
    </div>

    @*These are always shown to avoid brief flashes while navigating *@
    <Button Enabled="@folderIsWritable" class="me-1" ButtonStyle="primary" OnPressed="@OpenUploaderForm">
        Upload
    </Button>

    <AccessLimited AutoRedirectIfNotLoggedIn="@false" RequiredAccess="GroupType.RestrictedUser">

        @if (!showNewFolderCreate)
        {
            <StatusMessageShower Message="@createMessage" Type="@createMessageType" ExtraCSS="mt-1"
                                 OnClosed="@ClearCreateMessage"/>
        }

        <StatusMessageShower Message="@statusMessage" Type="@statusMessageType" ExtraCSS="mt-1"
                             OnClosed="@ClearStatusMessage"/>

        <Button Enabled="@(parsedFolderInfo != null)" class="me-1" ButtonStyle="info"
                OnPressed="@(() => showFolderInfo = !showFolderInfo)">
            @if (!showFolderInfo)
            {
                <span>Show Folder Info</span>
            }
            else
            {
                <span>Hide Folder Info</span>
            }
        </Button>
        <Button Enabled="@folderIsWritable" class="me-1" ButtonStyle="success" OnPressed="@ToggleNewFolderCreate">
            New Folder
        </Button>
        <Button Enabled="@CanMoveFolder" class="me-1" ButtonStyle="secondary" OnPressed="@ToggleFolderMove">
            Move
        </Button>

        @* Always show this to reduce flicker of the buttons *@
        @if (parsedFolderInfo?.ModificationLocked == true)
        {
            <Button Enabled="@CanEditLockedStatus" Spinner="@processing" class="mx-1"
                    ButtonStyle="@EditLockedStatusButtonType" OnPressed="@UnlockCurrentFolder">
                Unlock Folder Properties
            </Button>
        }
        else
        {
            <Button Enabled="@CanEditLockedStatus" Spinner="@processing" class="mx-1"
                    ButtonStyle="@EditLockedStatusButtonType" OnPressed="@LockCurrentFolder">
                Lock Folder Properties
            </Button>
        }

        @* Always show this to reduce flicker of the buttons *@
        <Button Enabled="@CanDeleteFolder" Spinner="@processing" class="me-1"
                ButtonStyle="danger" OnPressed="@StartFolderDelete">
            Delete This Folder
        </Button>

        @if (showFolderInfo)
        {
            @if (parsedFolderInfo == null)
            {
                <p class="mt-3">Folder info doesn't exist</p>
            }
            else
            {
                <h5 class="mt-3">Info About Folder ID: @parsedFolderInfo.Id</h5>
                <ul>
                    <li><strong>Name</strong>: @parsedFolderInfo.Name</li>
                    <li><strong>Readable by</strong>: @parsedFolderInfo.ReadAccess.ToUserReadableString()</li>
                    <li><strong>Writable by</strong>: @parsedFolderInfo.WriteAccess.ToUserReadableString()</li>
                    <li><strong>Special</strong>: @parsedFolderInfo.Special</li>
                    <li><strong>Parent</strong>: @(parsedFolderInfo.ParentId?.ToString() ?? "root")</li>
                    <li><strong>Size</strong>: @parsedFolderInfo.Size</li>
                    <li>
                        <strong>Owned by</strong>:
                        @if (parsedFolderInfo.OwnerId == null)
                        {
                            <span>system</span>
                        }
                        else
                        {
                            <UsernameDisplayer UserId="@parsedFolderInfo.OwnerId"/>
                        }
                    </li>
                    <li><strong>Created</strong>: <RecentTimeShortener Time="@parsedFolderInfo.CreatedAt"/></li>
                    <li><strong>Updated</strong>: <RecentTimeShortener Time="@parsedFolderInfo.UpdatedAt"/></li>
                    @if (parsedFolderInfo.LastModifiedById != null)
                    {
                        <li>
                            <strong>Properties modified by</strong> (excluding contained files):
                            <UsernameDisplayer UserId="@parsedFolderInfo.LastModifiedById"/>
                        </li>
                    }

                    <li><strong>Allow Parentless</strong>: @parsedFolderInfo.AllowParentless</li>
                    <li><strong>Properties Locked</strong>: @parsedFolderInfo.ModificationLocked</li>

                    @if (parsedFolderInfo.MovedFromLocation != null)
                    {
                        <li>
                            <strong>Previous item location</strong> (this was recently moved):
                            @parsedFolderInfo.MovedFromLocation
                        </li>
                    }
                </ul>

                @if (!parsedFolderInfo.Special && !parsedFolderInfo.ModificationLocked && folderIsWritable)
                {
                    <StorageItemFolderEditor Data="@parsedFolderInfo"/>
                }
            }
        }

        @if (showMoveFolder)
        {
            <p class="mt-2">Select the folder to move this folder to:</p>

            <FolderSelector CurrentPath="@targetMovePath" NonWritableWarning="@true" OnFolderChange="@BrowseMoveFolder"/>

            <Button Enabled="@(!processing)" class="mb-1" ButtonStyle="primary" OnPressed="@PerformMove"
                    Spinner="@processing">
                Move
            </Button>
        }

        @if (showNewFolderCreate)
        {
            <form class="mt-3">
                <div class="row">
                    <div class="mb-3 col-md-12">
                        <label class="form-label" for="newFolderName">New Folder Name</label>
                        <input type="text" class="form-control" id="newFolderName" @bind="newFolderName"
                               @bind:event="oninput">
                    </div>
                </div>

                <div class="row">
                    <div class="mb-3 col-md-6">
                        <label class="form-label" for="newFolderReadAccess">Read Access</label>
                        <select class="form-select" id="newFolderReadAccess" @bind="newFolderReadAccess">
                            @foreach (var name in Enum.GetNames<FileAccess>())
                            {
                                <option value="@name">@name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3 col-md-6">
                        <label class="form-label" for="newFolderWriteAccess">Write Access</label>
                        <select class="form-select" id="newFolderWriteAccess" @bind="newFolderWriteAccess">
                            @foreach (var name in Enum.GetNames<FileAccess>())
                            {
                                <option value="@name">@name</option>
                            }
                        </select>
                    </div>
                </div>

                <StatusMessageShower Message="@createMessage" Type="@createMessageType"/>
                <Button class="my-1" Enabled="@(!processingNewForm && !string.IsNullOrEmpty(newFolderName))"
                        OnPressed="@CreateNew" Spinner="@processingNewForm">
                    Create
                </Button>
            </form>
        }

    </AccessLimited>
}

<h4 class="mt-4">Storage Statistics</h4>

@if (loadingStats)
{
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
}
else if (usageStats == null)
{
    <span>Error: @usageStatsLoadError</span>
}
else
{
    <span>
        Used total storage: @usageStats.UsedBytes.BytesToGiB() (note: only updated every 30 minutes and
        excluding DevBuilds)
    </span>
}

@code {

    private readonly List<TableColumn> columns = new()
    {
        new TableColumn("Type", false),
        new TableColumn("Name", true),
        new TableColumn("Size", true),
        new TableColumn("Access", false),
    };

    private readonly List<string> uploadErrors = new();
    private readonly List<IBrowserFile> filesToBeUploaded = new();
    private readonly SemaphoreSlim requestNextChunksSemaphore = new(1, 1);

    private bool folderPathParsed;

    private long? parsedFolderId;

    private StorageItemDTO? parsedFolderInfo;
    private StorageItemDTO? shownFile;

    private bool folderIsWritable;

    private bool showFolderInfo;

    private string? createMessage;
    private SiteNoticeType createMessageType;

    private bool showNewFolderCreate;
    private bool processingNewForm;

    private string? newFolderName;
    private FileAccess newFolderReadAccess;
    private FileAccess newFolderWriteAccess;

    private bool showMoveFolder;
    private string? targetMovePath;

    /// <summary>
    ///   Processing flag for <see cref="parsedFolderInfo"/>
    /// </summary>
    private bool processing;

    private string? statusMessage;
    private SiteNoticeType statusMessageType;

    private bool showUploadOverlay;
    private bool uploadInProgress;
    private string? uploadStatus;
    private int dragLevel;

    private string? currentFileUploadMessage;
    private int totalChunks;
    private int alreadyUploadedChunks;
    private long alreadyUploadedChunkDataBytes;

    /// <summary>
    ///   If true uploading is in progress, and new uploads can't start
    /// </summary>
    private bool uploading;

    private StorageUsageStats? usageStats;
    private bool loadingStats = true;
    private string usageStatsLoadError = string.Empty;

    private ElementReference dropArea;

    private bool registered;

    [CascadingParameter]
    public IModalService Modal { get; set; } = null!;

    private bool ShouldShowUploaderOverlay => showUploadOverlay || uploadInProgress || uploadErrors.Count > 0;

    private bool CanEditLockedStatus => !processing && parsedFolderInfo is { Special: false } &&
        (CurrentUserInfo.Groups!.HasGroup(GroupType.Admin) || CurrentUserInfo.Info!.Id == parsedFolderInfo.OwnerId);

    private bool CanDeleteFolder => !processing && parsedFolderInfo is
    {
        Special: false, ModificationLocked: false, Important: false,
    } && (CurrentUserInfo.Groups!.HasGroup(GroupType.Admin) || (parsedFolderInfo.ParentId != null
        && folderIsWritable));

    private bool CanMoveFolder => parsedFolderInfo is
    {
        Special: false, ModificationLocked: false, Important: false,
    } && (CurrentUserInfo.Groups!.HasGroup(GroupType.Admin) || (parsedFolderInfo.ParentId != null
        && folderIsWritable));

    private string EditLockedStatusButtonType
    {
        get
        {
            if (parsedFolderInfo == null)
                return "secondary";

            if (parsedFolderInfo.ModificationLocked)
                return "warning";

            return "secondary";
        }
    }

    public Files()
    {
        BasePath = "files/";

        DefaultPageSize = 100;

        // We can only fetch data once we have parsed the current path to a folder id
        AutoFetchDataOnInit = false;
        AutoSetReactToParameterChangeAfterDataReceived = false;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!registered)
        {
            registered = true;
            await NotificationHandler.Register<FolderContentsUpdated>(this);
            await NotificationHandler.Register<StorageItemUpdated>(this);
        }

        await base.OnParametersSetAsync();
        var pathParseTask = ParseCurrentPath();

        if (usageStats == null)
            await FetchStorageStats();

        await pathParseTask;
    }

    public override Task SetParametersAsync(ParameterView parameters)
    {
        this.SetParametersFromQueryString(NavManager);

        return base.SetParametersAsync(parameters);
    }

    public Task Handle(FolderContentsUpdated notification, CancellationToken cancellationToken)
    {
        return HandleItemNotification(notification);
    }

    public Task Handle(StorageItemUpdated notification, CancellationToken cancellationToken)
    {
        // Detect current folder and shown sidebar item changes
        if (notification.Item.Id == parsedFolderInfo?.Id)
        {
            parsedFolderInfo = notification.Item;
            StateHasChanged();
        }
        else if (notification.Item.Id == shownFile?.Id)
        {
            shownFile = notification.Item;
            StateHasChanged();
        }

        return Task.CompletedTask;
    }

    public void GetWantedListenedGroups(IUserGroupData currentUserGroups, ISet<string> groups)
    {
        // We can't register for listeners before the folder path is parsed to a folder id
        if (!folderPathParsed)
            return;

        // Current folder properties listening
        if (parsedFolderId != null)
            groups.Add(NotificationGroups.StorageItemUpdatedPrefix + parsedFolderId);

        // Current file properties listening (only if we are looking at a folder)
        if (shownFile != null)
            groups.Add(NotificationGroups.StorageItemUpdatedPrefix + shownFile.Id);

        string folderId = parsedFolderId != null ? parsedFolderId.ToString()! : "root";

        // Folder content change listening
        groups.Add(NotificationGroups.FolderContentsUpdatedPublicPrefix + folderId);

        if (currentUserGroups.HasAccessLevel(GroupType.RestrictedUser))
            groups.Add(NotificationGroups.FolderContentsUpdatedRestrictedUserPrefix + folderId);
        if (currentUserGroups.HasAccessLevel(GroupType.User))
            groups.Add(NotificationGroups.FolderContentsUpdatedUserPrefix + folderId);
        if (currentUserGroups.HasAccessLevel(GroupType.Developer))
            groups.Add(NotificationGroups.FolderContentsUpdatedDeveloperPrefix + folderId);
        if (currentUserGroups.HasAccessLevel(GroupType.Admin) || (parsedFolderInfo?.OwnerId != null &&
                CurrentUserInfo?.Info?.Id == parsedFolderInfo.OwnerId))
        {
            groups.Add(NotificationGroups.FolderContentsUpdatedOwnerPrefix + folderId);
        }
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();
        await NotificationHandler.Unregister<FolderContentsUpdated>(this);
        await NotificationHandler.Unregister<StorageItemUpdated>(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // This was refactored as there was a warning comparing the entire area equality to "default" so hopefully
        // this is equivalent
        if (dropArea.Context != null)
        {
            await JS.InvokeVoidAsync("registerFileDropArea", dropArea, "filesToUploadSelection");
        }
    }

    protected override Dictionary<string, string?> CreatePageRequestParams()
    {
        var requestParams = base.CreatePageRequestParams();

        requestParams["parentId"] = parsedFolderId?.ToString() ?? string.Empty;

        return requestParams;
    }

    protected override void PruneRequestParams(Dictionary<string, string?> queryParams)
    {
        base.PruneRequestParams(queryParams);

        queryParams.Remove("parentId");
    }

    protected override Task<PagedResult<StorageItemInfo>?> StartQuery(Dictionary<string, string?> requestParams)
    {
        return Http.GetFromJsonAsync<PagedResult<StorageItemInfo>>(
            QueryHelpers.AddQueryString($"api/v1/Files/folderContents", requestParams));
    }

    protected override async Task OnQuerySent(Dictionary<string, string?> requestParams)
    {
        await base.OnQuerySent(requestParams);
        await URLHelper.UpdateUrlHistoryIfChanged(requestParams);
    }

    private async Task ParseCurrentPath()
    {
        folderPathParsed = false;
        parsedFolderInfo = null;
        folderIsWritable = false;
        showNewFolderCreate = false;
        shownFile = null;
        VisibleFetchInProgress = true;
        Error = null;

        // When changing paths stop showing the folder move and old item related data
        showMoveFolder = false;
        statusMessage = null;

        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.GetAsync(QueryHelpers.AddQueryString("api/v1/Files/itemFromPath", "path", NonNullPath));
        }
        catch (HttpRequestException e)
        {
            Error = $"Network request failed: {e.Message}";
            VisibleFetchInProgress = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var content = await result.Content.ReadAsStringAsync();
        VisibleFetchInProgress = false;

        if (result.StatusCode != HttpStatusCode.OK)
        {
            Error = $"Failed to process current path: {content}";
            if (string.IsNullOrEmpty(content))
                Error += result.StatusCode.ToString();
        }
        else
        {
            var parsedResult = JsonSerializer.Deserialize<PathParseResult>(content,
                new JsonSerializerOptions(JsonSerializerDefaults.Web));
            if (parsedResult != null)
            {
                // FinalItem may be null here if we are looking at the root folder
                folderPathParsed = true;

                if (parsedResult.FinalItem?.Ftype == FileType.File)
                {
                    // We should show a file currently
                    parsedFolderInfo = parsedResult.ParentFolder;
                    shownFile = parsedResult.FinalItem;
                }
                else
                {
                    parsedFolderInfo = parsedResult.FinalItem;
                }

                parsedFolderId = parsedFolderInfo?.Id;

                VisibleFetchInProgress = true;

                await NotificationHandler.NotifyWantedGroupsChanged();
                await DetectWriteAccessToFolder();
                await FetchData();
            }
            else
            {
                Error = "Failed to parse response JSON";
            }
        }
    }

    private async Task DetectWriteAccessToFolder()
    {
        bool newWritable;

        if (parsedFolderId == null)
        {
            // Only admins can write to the root folder
            newWritable = CurrentUserInfo.HasGroup(GroupType.Admin);
        }
        else
        {
            newWritable = parsedFolderInfo!.WriteAccess.IsAccessibleTo(CurrentUserInfo.Groups,
                CurrentUserInfo.Info?.Id, parsedFolderInfo.OwnerId);
        }

        if (newWritable != folderIsWritable)
        {
            folderIsWritable = newWritable;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ToggleNewFolderCreate()
    {
        if (showNewFolderCreate)
        {
            showNewFolderCreate = false;
        }
        else
        {
            showNewFolderCreate = true;
            createMessage = null;

            // Reset form status
            newFolderName = null;

            // By default use the parent folder access (unless at the root folder)
            if (parsedFolderInfo != null)
            {
                newFolderReadAccess = parsedFolderInfo.ReadAccess;
                newFolderWriteAccess = parsedFolderInfo.WriteAccess;
            }
            else
            {
                newFolderReadAccess = FileAccess.OwnerOrAdmin;
                newFolderWriteAccess = FileAccess.OwnerOrAdmin;
            }
        }

        StateHasChanged();
    }

    private async void CreateNew()
    {
        processingNewForm = true;
        createMessage = null;
        createMessageType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.PostAsJsonAsync("api/v1/Files/createFolder", new CreateFolderForm
            {
                Name = newFolderName!,
                ParentFolder = parsedFolderId,
                ReadAccess = newFolderReadAccess,
                WriteAccess = newFolderWriteAccess,
            });
        }
        catch (HttpRequestException e)
        {
            createMessage = $"Network request failed: {e.Message}";
            processingNewForm = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        processingNewForm = false;
        var content = await result.Content.ReadAsStringAsync();

        if (!result.IsSuccessStatusCode)
        {
            createMessage = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            createMessage = content;
            createMessageType = SiteNoticeType.Info;

            // Stop showing the form
            showNewFolderCreate = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private void ToggleFolderMove()
    {
        if (showMoveFolder)
        {
            showMoveFolder = false;
        }
        else
        {
            showMoveFolder = true;

            // TODO: should there be a way to make the target folder "sticky" to allow quickly putting things in the
            // same place
            targetMovePath = null;
        }

        StateHasChanged();
    }

    private void HandleDragEnter()
    {
        // The drag level is a workaround for the problem of child elements receiving the drag enter before the
        // parent receives drag leave (from the event bubbling up from the child)
        // see: https://stackoverflow.com/questions/7110353/html5-dragleave-fired-when-hovering-a-child-element
        ++dragLevel;
        showUploadOverlay = dragLevel > 0;
    }

    private void HandleDragOver()
    {
        // This empty method is needed, otherwise drops are not detected
    }

    private void HandleDragLeave()
    {
        --dragLevel;
        showUploadOverlay = dragLevel > 0;
    }

    private async Task OnDrop()
    {
        // Make sure the JS event listener gets in first
        await Task.Delay(1);

        // The above delay should have given enough time for OnInputFilesChanged to have ran
        Console.WriteLine("Auto-starting uploads as we got a drop event");

        showUploadOverlay = true;
        await StartUploads();
    }

    private async Task OnInputFilesChanged(InputFileChangeEventArgs args)
    {
        filesToBeUploaded.Clear();

        if (args.FileCount < 1)
            return;

        try
        {
            if (args.FileCount > 1)
            {
                foreach (var file in args.GetMultipleFiles(100))
                {
                    filesToBeUploaded.Add(file);
                }
            }
            else
            {
                filesToBeUploaded.Add(args.File);
            }

            await JS.InvokeVoidAsync("storeFileInputFilesForLaterUse", "filesToUploadSelection");
        }
        catch (Exception e)
        {
            uploadErrors.Add($"Error processing InputFile change: {e}");
        }
    }

    private Task StartFileSelectorUploads()
    {
        return StartUploads();
    }

    private void OpenUploaderForm()
    {
        showUploadOverlay = true;
    }

    private void CloseUploaderFormIfCanBeClosed()
    {
        showUploadOverlay = false;
    }

    private void ClearUploadErrors()
    {
        uploadErrors.Clear();
    }

    private async Task StartUploads()
    {
        if (uploading)
        {
            Console.WriteLine("Not starting another upload as one is in progress already");
            return;
        }

        uploading = true;

        await BeginNextUpload();

        Console.WriteLine("Uploads are now finished");
        uploading = false;
    }

    /// <summary>
    ///   Starts uploading the next file we should upload. Or stops if we have no more files to upload.
    ///   Should not be called directly, call StartUploads instead
    /// </summary>
    private async Task BeginNextUpload()
    {
        if (filesToBeUploaded.Count > 100)
        {
            uploadErrors.Add("Too many files to upload at once. Maximum is 100");
            return;
        }

        IBrowserFile? toUpload = null;

        while (filesToBeUploaded.Count > 0)
        {
            toUpload = filesToBeUploaded.First();
            filesToBeUploaded.Remove(toUpload);

            if (toUpload.Size > AppInfo.MaxGeneralFileStoreSize)
            {
                uploadErrors.Add($"File \"{toUpload.Name}\" is too large. Max size is: " +
                    $"{AppInfo.MaxGeneralFileStoreSize.BytesToMiB()}");
                toUpload = null;
                continue;
            }

            if (PathParser.IsExtensionUppercase(toUpload.Name))
            {
                uploadErrors.Add($"File \"{toUpload.Name}\" has uppercase characters in the extension, " +
                    "this is not allowed");
                toUpload = null;
                continue;
            }

            break;
        }

        if (toUpload == null)
        {
            uploadInProgress = false;
            uploadStatus = null;
            showUploadOverlay = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        uploadStatus = $"Uploading: \"{toUpload.Name}\" with size of {toUpload.Size.BytesToMiB()}";
        currentFileUploadMessage = null;
        uploadInProgress = true;
        await InvokeAsync(StateHasChanged);

        // First get the upload URL from the server
        try
        {
            // Before uploading make sure the file would not be a duplicate version
            // TODO: could make this a lot better with actual hash calculations but then also on the client we'd need
            // to do that
            var duplicate = await CheckIsFileToUploadDuplicate(toUpload, parsedFolderInfo);
            if (duplicate != null)
            {
                // Show confirmation first (in case someone has changed file with the same size they really want to
                // upload
                var parameters = new ModalParameters
                {
                    { nameof(ConfirmDuplicateUpload.Name), toUpload.Name },
                    { nameof(ConfirmDuplicateUpload.UploadSize), duplicate.PreviousVersionSize },
                    { nameof(ConfirmDuplicateUpload.PreviousVersionTime), duplicate.PreviousVersionTime },
                };

                var modal = Modal.Show<ConfirmDuplicateUpload>("Upload a duplicate file?", parameters);

                var result = await modal.Result;

                if (result.Cancelled)
                {
                    // Skip to the next upload (if there is one)
                    await BeginNextUpload();
                    return;
                }
            }

            var url = await GetFileUploadUrl(toUpload, parsedFolderInfo);

            // Then begin the file upload
            await UploadFile(toUpload, url);
        }
        catch (Exception e)
        {
            uploadErrors.Add($"Exception while uploading \"{toUpload.Name}\": {e.Message}");
        }

        // And start the next upload if we still have files to upload
        await BeginNextUpload();
    }

    private async Task<FileDuplicateCheckResponse?> CheckIsFileToUploadDuplicate(IBrowserFile file, StorageItemDTO? parentFolder)
    {
        var result = await Http.PostAsJsonAsync("api/v1/Files/checkUploadDuplicate",
            new UploadFileRequestForm
            {
                Name = file.Name,
                Size = file.Size,

                // TODO: could maybe pass the last modified here to detect uploading the same file again

                MimeType = string.IsNullOrEmpty(file.ContentType) ? "application/octet-stream" : file.ContentType,
                ParentFolder = parentFolder?.Id,
            });

        var content = await result.Content.ReadAsStringAsync();

        if (!result.IsSuccessStatusCode)
        {
            throw new Exception($"Failed to check file duplicate status before upload: {content}, {result.StatusCode}");
        }

        if (result.StatusCode == HttpStatusCode.NoContent)
            return null;

        return JsonSerializer.Deserialize<FileDuplicateCheckResponse>(content,
            HttpClientHelpers.GetOptionsWithSerializers()) ?? throw new NullDecodedJsonException();
    }

    private async Task<UploadFileResponse> GetFileUploadUrl(IBrowserFile file, StorageItemDTO? parentFolder)
    {
        var result = await Http.PostAsJsonAsync("api/v1/Files/startUpload",
            new UploadFileRequestForm
            {
                Name = file.Name,
                Size = file.Size,

                MimeType = string.IsNullOrEmpty(file.ContentType) ? "application/octet-stream" : file.ContentType,
                ParentFolder = parentFolder?.Id,

                // TODO: allow configuring these
                ReadAccess = parentFolder?.ReadAccess ?? FileAccess.Developer,
                WriteAccess = parentFolder?.WriteAccess ?? FileAccess.OwnerOrAdmin,
            });

        var content = await result.Content.ReadAsStringAsync();

        if (!result.IsSuccessStatusCode)
        {
            throw new Exception($"Failed to get the upload URL from the server: {content}, {result.StatusCode}");
        }

        return JsonSerializer.Deserialize<UploadFileResponse>(content,
            HttpClientHelpers.GetOptionsWithSerializers()) ?? throw new NullDecodedJsonException();
    }

    private async Task UploadFile(IBrowserFile file, UploadFileResponse info)
    {
        string? error;

        if (info.Multipart != null)
        {
            error = await UploadMultipartFile(file.Name, info.Multipart);
        }
        else
        {
            error = await UploadSinglePartFile(file.Name, info.UploadURL ??
                throw new ArgumentException("no upload URL in non-multipart upload"));
        }

        if (!string.IsNullOrEmpty(error))
        {
            uploadErrors.Add(error);
        }
        else
        {
            // Upload is a success, report it
            await ReportFileUploadComplete(info);
        }
    }

    private ValueTask<string> UploadSinglePartFile(string fileName, string url)
    {
        return JS.InvokeAsync<string>("putFormFile", fileName, url);
    }

    private void UpdateCurrentChunkMessage()
    {
        currentFileUploadMessage = $"{alreadyUploadedChunks}/{totalChunks} chunks " +
            alreadyUploadedChunkDataBytes.BytesToMiB(1) + " uploaded";
    }

    private async ValueTask<string?> UploadMultipartFile(string fileName, MultipartFileUpload upload)
    {
        totalChunks = upload.TotalChunks;
        alreadyUploadedChunks = 0;
        alreadyUploadedChunkDataBytes = 0;
        UpdateCurrentChunkMessage();
        await InvokeAsync(StateHasChanged);

        if (upload.NextChunks == null || upload.NextChunks.Count < 1)
            throw new ArgumentException("Multipart upload didn't specify initial chunks to upload");

        var startingChunks = upload.NextChunks.AsEnumerable().Chunk((int)Math.Ceiling(
            upload.NextChunks.Count / (float)AppInfo.MultipartSimultaneousUploads)).ToList();

        var uploadTasks = new List<ValueTask<string?>>();

        // If there are less than MultipartSimultaneousUploads chunks, we have fewer tasks, or
        // when there are exactly 4 chunks to upload, we end up with 2 tasks. So we use the upload task count
        // here, but just guard against the case where we got too many chunks
        if (startingChunks.Count > AppInfo.MultipartSimultaneousUploads)
        {
            await Console.Error.WriteAsync($"Number of starting chunk lists: {startingChunks.Count} " +
                $"is over task count: {AppInfo.MultipartSimultaneousUploads}");
        }

        foreach (var initialChunks in startingChunks)
        {
            uploadTasks.Add(UploadChunksUntilDone(fileName, upload.ChunkRetrieveToken, initialChunks));
        }

        string? error = null;

        foreach (var task in uploadTasks)
        {
            string? currentError;
            try
            {
                currentError = await task;
            }
            catch (Exception e)
            {
                await Console.Error.WriteLineAsync($"Failed to run chunk upload task: {e}");
                currentError = e.ToString();
            }

            if (string.IsNullOrEmpty(currentError))
            {
                if (error == null)
                {
                    error = currentError;
                }
                else
                {
                    error += $". Another chunk task failed: {currentError}";
                }
            }
        }

        try
        {
            await JS.InvokeVoidAsync("reportFormFileChunksUploaded", fileName);
        }
        catch (Exception e)
        {
            await Console.Error.WriteLineAsync($"Failed to call multipart file upload chunks finished: #{e}");
        }

        return error;
    }

    private async ValueTask<string?> UploadChunksUntilDone(string fileName, string moreChunksToken,
        IEnumerable<MultipartFileUpload.FileChunk> initialChunks)
    {
        Console.WriteLine("Starting chunk upload task");
        var error = await UploadSingleChunkList(fileName, initialChunks);

        if (error != null)
            return error;

        // Keep uploading chunks until we run out
        while (true)
        {
            MultipartFileUpload nextUpload;
            await requestNextChunksSemaphore.WaitAsync();

            try
            {
                var result = await Http.PostAsJsonAsync("api/v1/Files/moreChunks",
                    new MoreChunksRequestForm { Token = moreChunksToken });

                var content = await result.Content.ReadAsStringAsync();

                if (!result.IsSuccessStatusCode)
                {
                    throw new Exception($"Failed to get more chunks from the server: {content}, {result.StatusCode}");
                }

                nextUpload = JsonSerializer.Deserialize<MultipartFileUpload>(content,
                    HttpClientHelpers.GetOptionsWithSerializers()) ?? throw new NullDecodedJsonException();
            }
            catch (Exception e)
            {
                return $"Fetching more chunks failed: {e}";
            }
            finally
            {
                requestNextChunksSemaphore.Release();
            }

            if (nextUpload.NextChunks == null)
            {
                Console.WriteLine("A chunk upload task finished");
                return null;
            }

            error = await UploadSingleChunkList(fileName, nextUpload.NextChunks);

            if (error != null)
                return error;
        }
    }

    private async ValueTask<string?> UploadSingleChunkList(string fileName,
        IEnumerable<MultipartFileUpload.FileChunk> chunks)
    {
        bool uploaded = false;
        foreach (var chunk in chunks)
        {
            uploaded = true;
            var error = await JS.InvokeAsync<string?>("putFormFileChunk", fileName, chunk.UploadURL,
                chunk.Offset, chunk.Length);

            if (error != null)
            {
                Console.WriteLine($"Failed to upload chunk {chunk.ChunkNumber}");
                return error;
            }

            Interlocked.Add(ref alreadyUploadedChunkDataBytes, chunk.Length);
            Interlocked.Increment(ref alreadyUploadedChunks);
            UpdateCurrentChunkMessage();
            await InvokeAsync(StateHasChanged);
        }

        if (!uploaded)
            await Console.Error.WriteLineAsync($"{nameof(UploadSingleChunkList)} was given an empty list of chunks");

        return null;
    }

    private async Task ReportFileUploadComplete(UploadFileResponse info)
    {
        var result = await Http.PostAsJsonAsync("api/v1/Files/finishUpload", info);

        var content = await result.Content.ReadAsStringAsync();

        if (!result.IsSuccessStatusCode)
        {
            throw new Exception($"Failed to report finished upload: {content}, {result.StatusCode}");
        }
    }

    private async Task FetchStorageStats()
    {
        loadingStats = true;
        usageStatsLoadError = string.Empty;
        usageStats = null;

        try
        {
            usageStats = await Http.GetFromJsonAsync<StorageUsageStats>("api/v1/Files/totalUsed");
        }
        catch (Exception e)
        {
            usageStatsLoadError = e.Message;
        }

        loadingStats = false;
        await InvokeAsync(StateHasChanged);
    }

    private async void LockCurrentFolder()
    {
        processing = true;
        statusMessage = null;
        statusMessageType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.PostAsync($"api/v1/Files/{parsedFolderId}/lock", new StringContent(string.Empty));
        }
        catch (HttpRequestException e)
        {
            statusMessage = $"Network request failed: {e.Message}";
            processing = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        processing = false;

        if (!result.IsSuccessStatusCode)
        {
            var content = await result.Content.ReadAsStringAsync();
            statusMessage = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            statusMessage = "Folder properties (name, read access, write access) are now locked against " +
                "modification. The folder also can't be deleted.";
            statusMessageType = SiteNoticeType.Primary;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async void UnlockCurrentFolder()
    {
        processing = true;
        statusMessage = null;
        statusMessageType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.DeleteAsync($"api/v1/Files/{parsedFolderId}/lock");
        }
        catch (HttpRequestException e)
        {
            statusMessage = $"Network request failed: {e.Message}";
            processing = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        processing = false;

        if (!result.IsSuccessStatusCode)
        {
            var content = await result.Content.ReadAsStringAsync();
            statusMessage = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            statusMessage = "Folder can now be edited again";
            statusMessageType = SiteNoticeType.Secondary;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async void StartFolderDelete()
    {
        var folder = parsedFolderId;

        if (folder == null)
            return;

        var parameters = new ModalParameters
        {
            { nameof(ConfirmDelete.Name), parsedFolderInfo?.Name ?? folder.Value.ToString() },
        };

        var modal = Modal.Show<ConfirmDelete>("Delete this folder?", parameters);

        var result = await modal.Result;

        if (result.Cancelled)
            return;

        await ConfirmDeleteCurrentFolder(folder.Value);
    }

    private async Task ConfirmDeleteCurrentFolder(long id)
    {
        processing = true;
        statusMessage = null;
        statusMessageType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.DeleteAsync($"api/v1/Files/{id}");
        }
        catch (HttpRequestException e)
        {
            statusMessage = $"Network request failed: {e.Message}";
            processing = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        processing = false;

        if (!result.IsSuccessStatusCode)
        {
            var content = await result.Content.ReadAsStringAsync();
            statusMessage = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            statusMessage = "Current folder has been deleted";
            statusMessageType = SiteNoticeType.Warning;
        }

        await InvokeAsync(StateHasChanged);
    }

    private void ClearStatusMessage()
    {
        statusMessage = null;
    }

    private void ClearCreateMessage()
    {
        createMessage = null;
    }

    private void BrowseMoveFolder(string? newFolder)
    {
        targetMovePath = newFolder;
        StateHasChanged();
    }

    private async Task PerformMove()
    {
        processing = true;
        statusMessage = null;
        statusMessageType = SiteNoticeType.Danger;
        await InvokeAsync(StateHasChanged);

        HttpResponseMessage result;

        try
        {
            result = await Http.PostAsJsonAsync($"api/v1/Files/{parsedFolderId}/move",
                targetMovePath ?? string.Empty);
        }
        catch (HttpRequestException e)
        {
            statusMessage = $"Network request failed: {e.Message}";
            processing = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        processing = false;
        var content = await result.Content.ReadAsStringAsync();

        if (!result.IsSuccessStatusCode)
        {
            statusMessage = $"Error, server responded with: {content}, {result.StatusCode}";
        }
        else
        {
            statusMessage = $"Folder has been successfully moved to {content}";
            statusMessageType = SiteNoticeType.Primary;
            showMoveFolder = false;
        }

        await InvokeAsync(StateHasChanged);
    }

}
